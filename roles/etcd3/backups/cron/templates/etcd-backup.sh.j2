#!/bin/bash
# Etcd data backup script - runs periodically
# Generated by Ansible - do not edit manually
#
# Usage: etcd-backup.sh [OPTIONS]
#
# OPTIONS:
#   --help          Show this help message
#   --force         Force backup even if cluster is unhealthy
#   --dry-run       Show what would be done without making changes
#
# Exit codes:
#   0 - Success (backup completed)
#   1 - Fatal error (backup failed)

set -euo pipefail
set -o errtrace  # Inherit ERR trap in functions

# Trap errors and exit
trap 'error_handler $? $LINENO' ERR
trap 'log "ERROR" "Script interrupted"; exit 1' INT TERM

error_handler() {
    log "ERROR" "Command failed with exit code $1 at line $2"
    log "ERROR" "Last command: ${BASH_COMMAND}"
    exit 1
}

# AWS credentials from environment (only for aws-kms method)
export AWS_ACCESS_KEY_ID="{{ aws_access_key_id | default('') }}"
export AWS_SECRET_ACCESS_KEY="{{ aws_secret_access_key | default('') }}"
export AWS_DEFAULT_REGION="{{ aws_default_region | default('us-east-1') }}"

BACKUP_DIR="{{ etcd_cluster_backup.directory }}"
ETCD_ENDPOINTS="{{ etcd_access_addresses }}"
CERT="{{ etcd_cert_paths.client.cert }}"
KEY="{{ etcd_cert_paths.client.key }}"
CACERT="{{ etcd_cert_paths.client.ca }}"
S3_BUCKET="{{ etcd_upload_backup.bucket }}"
S3_PREFIX="{{ etcd_upload_backup.prefix | default('') }}"
ENCRYPTION_METHOD="{{ step_ca_backup_encryption_method }}"
KMS_KEY_ID="{{ step_ca_backup_kms_key_id }}"
BACKUP_PASSWORD="{{ step_ca_backup_password }}"
CLUSTER_NAME="{{ etcd_cluster_name }}"
RETENTION_DAYS="{{ etcd_backup_retention_days }}"
HEALTHCHECK_URL="{{ backup_healthcheck_url }}"

log() {
    local level="$1"
    shift
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*"
}

# Show help
show_help() {
    sed -n '2,/^$/p' "$0" | sed 's/^# //' | sed 's/^#//'
    exit 0
}

# Parse arguments
FORCE_BACKUP=false
DRY_RUN=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            show_help
            ;;
        --force)
            FORCE_BACKUP=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        *)
            log "ERROR" "Unknown option: $1"
            show_help
            ;;
    esac
done

# Verify file exists on S3
verify_s3_file() {
    local s3_path="$1"
    log "INFO" "Checking if file exists on S3: $s3_path"
    
    if {{ bin_dir }}/aws s3api head-object \
        --bucket "$S3_BUCKET" \
        --key "$s3_path" >/dev/null 2>&1; then
        log "INFO" "✓ File exists on S3"
        return 0
    else
        log "WARN" "File does not exist on S3"
        return 1
    fi
}

# Download and verify S3 file checksum
verify_s3_checksum() {
    local s3_path="$1"
    local expected_checksum="$2"
    
    log "INFO" "Downloading file from S3 for verification..."
    local temp_file="/tmp/etcd-verify-$(date +%s).db"
    
    if ! {{ bin_dir }}/aws s3 cp "s3://${S3_BUCKET}/${s3_path}" "$temp_file" >/dev/null 2>&1; then
        log "ERROR" "Failed to download file from S3 for verification"
        rm -f "$temp_file"
        return 1
    fi
    
    log "INFO" "Calculating checksum of downloaded file..."
    local actual_checksum=$(sha256sum "$temp_file" | cut -d' ' -f1)
    rm -f "$temp_file"
    
    log "INFO" "Expected: $expected_checksum"
    log "INFO" "Actual:   $actual_checksum"
    
    if [ "$expected_checksum" = "$actual_checksum" ]; then
        log "INFO" "✓ Checksum verification PASSED"
        return 0
    else
        log "ERROR" "✗ Checksum verification FAILED"
        return 1
    fi
}

# Create etcd snapshot
create_snapshot() {
    local timestamp=$(date +%Y-%m-%d_%H-%M-%S)
    local year=$(date +%Y)
    local month=$(date +%m)
    local snapshot_file="${BACKUP_DIR}/${year}/${month}/${CLUSTER_NAME}-${timestamp}-snapshot.db"
    local encrypted_file="${snapshot_file}.kms"
    
    log "INFO" "Starting etcd snapshot creation..."
    log "INFO" "Timestamp: $timestamp"
    
    if [ "$DRY_RUN" = true ]; then
        log "INFO" "[DRY-RUN] Would create snapshot from $ETCD_ENDPOINTS"
        return 0
    fi
    
    # Create directory
    log "INFO" "Creating backup directory..."
    if ! mkdir -p "$(dirname "$snapshot_file")"; then
        log "ERROR" "Failed to create backup directory"
        return 1
    fi
    log "INFO" "✓ Directory created: $(dirname "$snapshot_file")"
    
    log "INFO" "Creating etcd snapshot..."
    if ! {{ bin_dir }}/etcdctl \
        --endpoints="$ETCD_ENDPOINTS" \
        --cert="$CERT" \
        --cacert="$CACERT" \
        --key="$KEY" \
        snapshot save "$snapshot_file"; then
        log "ERROR" "Failed to create etcd snapshot"
        return 1
    fi
    log "INFO" "✓ Snapshot created: $snapshot_file"
    
    log "INFO" "Verifying snapshot integrity..."
    if ! {{ bin_dir }}/etcdutl snapshot status "$snapshot_file" --write-out=table; then
        log "ERROR" "Snapshot verification failed"
        rm -f "$snapshot_file"
        return 1
    fi
    log "INFO" "✓ Snapshot integrity verified"
    
    # Calculate snapshot checksum
    local snapshot_checksum=$(sha256sum "$snapshot_file" | cut -d' ' -f1)
    log "INFO" "Snapshot checksum: $snapshot_checksum"
    
    # Encrypt based on method
    local final_file=""
    local s3_suffix=""
    
    case "$ENCRYPTION_METHOD" in
        aws-kms)
            log "INFO" "Encrypting snapshot with AWS KMS (key: $KMS_KEY_ID)..."
            if ! {{ bin_dir }}/aws kms encrypt \
                --key-id "$KMS_KEY_ID" \
                --plaintext "fileb://${snapshot_file}" \
                --output text \
                --query CiphertextBlob | base64 -d > "$encrypted_file"; then
                log "ERROR" "KMS encryption failed"
                rm -f "$snapshot_file"
                return 1
            fi
            log "INFO" "✓ KMS encryption completed"
            final_file="$encrypted_file"
            s3_suffix=".kms"
            ;;
            
        symmetric)
            log "INFO" "Encrypting snapshot with OpenSSL AES-256-CBC..."
            local enc_file="${snapshot_file}.enc"
            if ! openssl enc -aes-256-cbc -salt -pbkdf2 -iter 100000 \
                -in "$snapshot_file" -out "$enc_file" \
                -pass pass:"$BACKUP_PASSWORD"; then
                log "ERROR" "OpenSSL encryption failed"
                rm -f "$snapshot_file"
                return 1
            fi
            log "INFO" "✓ OpenSSL encryption completed"
            final_file="$enc_file"
            s3_suffix=".enc"
            ;;
            
        none)
            log "WARN" "No encryption - uploading plain snapshot (not recommended)"
            final_file="$snapshot_file"
            s3_suffix=""
            ;;
            
        *)
            log "ERROR" "Unknown encryption method: $ENCRYPTION_METHOD"
            rm -f "$snapshot_file"
            return 1
            ;;
    esac
    
    # Calculate final file checksum
    local final_checksum=$(sha256sum "$final_file" | cut -d' ' -f1)
    log "INFO" "Final file checksum: $final_checksum"
    
    # Upload to S3
    local s3_path="${S3_PREFIX}${CLUSTER_NAME}/${year}/${month}/$(basename ${snapshot_file})${s3_suffix}"
    log "INFO" "Uploading backup to S3: s3://${S3_BUCKET}/${s3_path}"
    
    if ! {{ bin_dir }}/aws s3 cp "$final_file" \
        "s3://${S3_BUCKET}/${s3_path}" \
        --metadata "backup-timestamp=${timestamp},snapshot-checksum=${snapshot_checksum},encrypted-checksum=${final_checksum}"; then
        log "ERROR" "Failed to upload backup to S3"
        rm -f "$snapshot_file" "$final_file"
        return 1
    fi
    log "INFO" "✓ Upload completed"
    
    # Verify upload
    log "INFO" "Verifying upload..."
    if ! verify_s3_file "$s3_path"; then
        log "ERROR" "Upload verification failed - file not found on S3"
        rm -f "$snapshot_file" "$final_file"
        return 1
    fi
    
    # Download and verify checksum
    log "INFO" "Verifying uploaded file integrity..."
    if ! verify_s3_checksum "$s3_path" "$final_checksum"; then
        log "ERROR" "Upload verification failed - checksum mismatch"
        rm -f "$snapshot_file" "$final_file"
        return 1
    fi
    log "INFO" "✓ Upload verification PASSED"
    
    # Update latest pointer
    log "INFO" "Updating 'latest' pointer..."
    if ! {{ bin_dir }}/aws s3 cp "$final_file" \
        "s3://${S3_BUCKET}/${S3_PREFIX}${CLUSTER_NAME}/latest-snapshot.db${s3_suffix}" \
        --metadata "backup-timestamp=${timestamp},snapshot-checksum=${snapshot_checksum},encrypted-checksum=${final_checksum},retention=long-term"; then
        log "WARN" "Failed to update latest pointer (non-fatal)"
    else
        log "INFO" "✓ Latest pointer updated"
    fi
    
    # Tag backup for retention
    log "INFO" "Tagging backup for retention policy..."
    {{ bin_dir }}/aws s3api put-object-tagging \
        --bucket "$S3_BUCKET" \
        --key "$s3_path" \
        --tagging "TagSet=[{Key=Type,Value=etcd-snapshot},{Key=Cluster,Value=${CLUSTER_NAME}},{Key=Timestamp,Value=${timestamp}},{Key=Retention,Value=long-term},{Key=Latest,Value=true}]" \
        >/dev/null 2>&1 || log "WARN" "Failed to set S3 tags (non-fatal)"
    
    # Keep local unencrypted snapshot
    log "INFO" "Saving local copy..."
    if ! cp "$snapshot_file" "${BACKUP_DIR}/${CLUSTER_NAME}-snapshot.db"; then
        log "WARN" "Failed to save local copy (non-fatal)"
    else
        log "INFO" "✓ Local copy saved"
    fi
    
    # Cleanup encrypted file
    log "INFO" "Cleaning up temporary files..."
    if [ "$final_file" != "$snapshot_file" ]; then
        rm -f "$final_file"
    fi
    log "INFO" "✓ Cleanup completed"
    
    log "INFO" "========================================"
    log "INFO" "Snapshot SUCCESS: s3://${S3_BUCKET}/${s3_path}"
    log "INFO" "Snapshot checksum: $snapshot_checksum"
    log "INFO" "Encrypted checksum: $final_checksum"
    log "INFO" "========================================"
    
    return 0
}

# Cleanup old backups
cleanup_old_backups() {
    log "INFO" "Cleaning up local backups older than ${RETENTION_DAYS} days..."
    
    local deleted_count=0
    while IFS= read -r file; do
        log "INFO" "Deleting old backup: $file"
        rm -f "$file"
        ((deleted_count++))
    done < <(find "$BACKUP_DIR" -type f -name "*.db" -mtime "+${RETENTION_DAYS}")
    
    log "INFO" "Deleted $deleted_count old backup(s)"
    
    # Cleanup empty directories
    find "$BACKUP_DIR" -type d -empty -delete
    log "INFO" "✓ Local cleanup completed"
}

# Main logic
main() {
    log "INFO" "========================================"
    log "INFO" "Etcd Backup Script Starting"
    log "INFO" "Time: $(date '+%Y-%m-%d %H:%M:%S')"
    log "INFO" "Cluster: $CLUSTER_NAME"
    log "INFO" "Endpoints: $ETCD_ENDPOINTS"
    log "INFO" "Encryption: $ENCRYPTION_METHOD"
    log "INFO" "S3 Bucket: s3://${S3_BUCKET}/${S3_PREFIX}${CLUSTER_NAME}"
    log "INFO" "Force backup: $FORCE_BACKUP"
    log "INFO" "Dry run: $DRY_RUN"
    log "INFO" "========================================"
    
    # Check etcd health
    log "INFO" "Checking etcd cluster health..."
    if {{ bin_dir }}/etcdctl --endpoints="$ETCD_ENDPOINTS" \
        --cert="$CERT" --cacert="$CACERT" --key="$KEY" \
        endpoint health > /dev/null 2>&1; then
        log "INFO" "✓ Etcd cluster is healthy"
    else
        if [ "$FORCE_BACKUP" = true ]; then
            log "WARN" "Etcd cluster is unhealthy, but force backup requested"
        else
            log "ERROR" "Etcd cluster is unhealthy, aborting backup"
            log "ERROR" "Use --force to backup anyway (may result in inconsistent data)"
            
            # Send healthcheck ping for failure
            if [ -n "$HEALTHCHECK_URL" ]; then
                curl -fsS --retry 3 "${HEALTHCHECK_URL}?status=cluster-unhealthy" > /dev/null 2>&1 || true
            fi
            
            return 1
        fi
    fi
    
    # Create snapshot
    log "INFO" "Starting snapshot operation..."
    if create_snapshot; then
        if [ "$DRY_RUN" = false ]; then
            # Cleanup old backups
            cleanup_old_backups
        fi
        
        # Send healthcheck ping if configured
        if [ -n "$HEALTHCHECK_URL" ] && [ "$DRY_RUN" = false ]; then
            log "INFO" "Sending healthcheck ping..."
            if curl -fsS --retry 3 "${HEALTHCHECK_URL}?status=success" > /dev/null 2>&1; then
                log "INFO" "✓ Healthcheck ping successful"
            else
                log "WARN" "Healthcheck ping failed (non-fatal)"
            fi
        fi
        
        log "INFO" "========================================"
        log "INFO" "Etcd Backup Completed Successfully"
        log "INFO" "========================================"
        return 0
    else
        log "ERROR" "========================================"
        log "ERROR" "Etcd Backup FAILED"
        log "ERROR" "========================================"
        
        # Send healthcheck ping for failure
        if [ -n "$HEALTHCHECK_URL" ] && [ "$DRY_RUN" = false ]; then
            curl -fsS --retry 3 "${HEALTHCHECK_URL}?status=failure" > /dev/null 2>&1 || true
        fi
        
        return 1
    fi
}

export ETCDCTL_API=3
main "$@"
