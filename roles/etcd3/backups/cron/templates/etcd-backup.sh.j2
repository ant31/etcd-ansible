#!/bin/bash
# Etcd data backup script - runs periodically
# Generated by Ansible - do not edit manually
#
# Usage: etcd-backup.sh [OPTIONS]
#
# OPTIONS:
#   --help          Show this help message
#   --force         Force backup even if cluster is unhealthy
#   --dry-run       Show what would be done without making changes
#
# Exit codes:
#   0 - Success (backup completed)
#   1 - Fatal error (backup failed)

set -euo pipefail
set -o errtrace  # Inherit ERR trap in functions

# Trap errors and exit
trap 'error_handler $? $LINENO' ERR
trap 'log "ERROR" "Script interrupted"; exit 1' INT TERM

error_handler() {
    log "ERROR" "Command failed with exit code $1 at line $2"
    log "ERROR" "Last command: ${BASH_COMMAND}"
    exit 1
}

# AWS credentials from environment (only for aws-kms method)
export AWS_ACCESS_KEY_ID="{{ aws_access_key_id | default('') }}"
export AWS_SECRET_ACCESS_KEY="{{ aws_secret_access_key | default('') }}"
export AWS_DEFAULT_REGION="{{ aws_default_region | default('us-east-1') }}"

BACKUP_DIR="{{ etcd_cluster_backup_directory }}"
ETCD_ENDPOINTS="{{ etcd_clusters[etcd_cluster_name].etcd_access_addresses }}"
CERT="{{ etcd_clusters[etcd_cluster_name].etcd_cert_paths.client.cert }}"
KEY="{{ etcd_clusters[etcd_cluster_name].etcd_cert_paths.client.key }}"
CACERT="{{ etcd_clusters[etcd_cluster_name].etcd_cert_paths.client.ca }}"
S3_BUCKET="{{ etcd_backup_s3_bucket }}"
S3_PREFIX="{{ etcd_backup_s3_prefix }}"
ENCRYPTION_METHOD="{{ step_ca_backup_encryption_method }}"
KMS_KEY_ID="{{ step_ca_backup_kms_key_id }}"
BACKUP_PASSWORD="{{ step_ca_backup_password }}"
CLUSTER_NAME="{{ etcd_cluster_name }}"
RETENTION_DAYS="{{ etcd_backup_retention_days }}"
HEALTHCHECK_URL="{{ backup_healthcheck_url }}"

log() {
    local level="$1"
    shift
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $*"
}

# Show help
show_help() {
    sed -n '2,/^$/p' "$0" | sed 's/^# //' | sed 's/^#//'
    exit 0
}

# Parse arguments
FORCE_BACKUP=false
DRY_RUN=false
INDEPENDENT_MODE=false
while [[ $# -gt 0 ]]; do
    case $1 in
        --help|-h)
            show_help
            ;;
        --force)
            FORCE_BACKUP=true
            shift
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --independent)
            INDEPENDENT_MODE=true
            shift
            ;;
        *)
            log "ERROR" "Unknown option: $1"
            show_help
            ;;
    esac
done

# Verify file exists on S3
verify_s3_file() {
    local s3_path="$1"
    log "INFO" "Checking if file exists on S3: $s3_path"
    
    if {{ bin_dir }}/aws s3api head-object \
        --bucket "$S3_BUCKET" \
        --key "$s3_path" >/dev/null 2>&1; then
        log "INFO" "✓ File exists on S3"
        return 0
    else
        log "WARN" "File does not exist on S3"
        return 1
    fi
}

# Download and verify S3 file checksum
verify_s3_checksum() {
    local s3_path="$1"
    local expected_checksum="$2"
    
    log "INFO" "Downloading file from S3 for verification..."
    local temp_file="/tmp/etcd-verify-$(date +%s).db"
    
    if ! {{ bin_dir }}/aws s3 cp "s3://${S3_BUCKET}/${s3_path}" "$temp_file" >/dev/null 2>&1; then
        log "ERROR" "Failed to download file from S3 for verification"
        rm -f "$temp_file"
        return 1
    fi
    
    log "INFO" "Calculating checksum of downloaded file..."
    local actual_checksum=$(sha256sum "$temp_file" | cut -d' ' -f1)
    rm -f "$temp_file"
    
    log "INFO" "Expected: $expected_checksum"
    log "INFO" "Actual:   $actual_checksum"
    
    if [ "$expected_checksum" = "$actual_checksum" ]; then
        log "INFO" "✓ Checksum verification PASSED"
        return 0
    else
        log "ERROR" "✗ Checksum verification FAILED"
        return 1
    fi
}

# Create etcd snapshot
create_snapshot() {
    local timestamp=$(date +%Y-%m-%d_%H-%M-%S)
    local year=$(date +%Y)
    local month=$(date +%m)
    local snapshot_file="${BACKUP_DIR}/${year}/${month}/${CLUSTER_NAME}-${timestamp}-snapshot.db"
    local encrypted_file="${snapshot_file}.kms"
    
    log "INFO" "Starting etcd snapshot creation..."
    log "INFO" "Timestamp: $timestamp"
    
    if [ "$DRY_RUN" = true ]; then
        log "INFO" "[DRY-RUN] Would create snapshot from $ETCD_ENDPOINTS"
        return 0
    fi
    
    # Create directory (already running as etcd user via cron)
    log "INFO" "Creating backup directory..."
    if ! mkdir -p "$(dirname "$snapshot_file")"; then
        log "ERROR" "Failed to create backup directory"
        log "ERROR" "Check permissions on {{ etcd_cluster_backup.directory }}"
        return 1
    fi
    log "INFO" "✓ Directory created: $(dirname "$snapshot_file")"
    
    # Use only the first endpoint for snapshot (etcd requirement)
    local first_endpoint=$(echo "$ETCD_ENDPOINTS" | cut -d',' -f1)
    log "INFO" "Creating etcd snapshot from: $first_endpoint"
    if ! {{ bin_dir }}/etcdctl \
        --endpoints="$first_endpoint" \
        --cert="$CERT" \
        --cacert="$CACERT" \
        --key="$KEY" \
        snapshot save "$snapshot_file"; then
        log "ERROR" "Failed to create etcd snapshot"
        return 1
    fi
    log "INFO" "✓ Snapshot created: $snapshot_file"
    
    log "INFO" "Verifying snapshot integrity..."
    if ! {{ bin_dir }}/etcdutl snapshot status "$snapshot_file" --write-out=table; then
        log "ERROR" "Snapshot verification failed"
        rm -f "$snapshot_file"
        return 1
    fi
    log "INFO" "✓ Snapshot integrity verified"
    
    # Calculate snapshot checksum
    local snapshot_checksum=$(sha256sum "$snapshot_file" | cut -d' ' -f1)
    log "INFO" "Snapshot checksum: $snapshot_checksum"
    
    # Encrypt based on method with validation
    local final_file=""
    local s3_suffix=""
    
    case "$ENCRYPTION_METHOD" in
        aws-kms)
            log "INFO" "Encrypting snapshot with AWS KMS (key: $KMS_KEY_ID)..."
            if ! {{ bin_dir }}/aws kms encrypt \
                --key-id "$KMS_KEY_ID" \
                --plaintext "fileb://${snapshot_file}" \
                --output text \
                --query CiphertextBlob | base64 -d > "$encrypted_file"; then
                log "ERROR" "KMS encryption failed"
                rm -f "$snapshot_file"
                return 1
            fi
            
            # Verify encrypted file exists and has content
            if [ ! -s "$encrypted_file" ]; then
                log "ERROR" "Encrypted file is empty or missing (encryption pipe failed)"
                rm -f "$snapshot_file" "$encrypted_file"
                return 1
            fi
            log "INFO" "✓ Encrypted file created: $(stat -f%z "$encrypted_file" 2>/dev/null || stat -c%s "$encrypted_file") bytes"
            
            # Test decrypt to verify encryption integrity
            log "INFO" "Validating encryption (test decrypt)..."
            local test_decrypt="/tmp/etcd-decrypt-test-$$.db"
            if ! {{ bin_dir }}/aws kms decrypt \
                --ciphertext-blob "fileb://${encrypted_file}" \
                --output text \
                --query Plaintext | base64 -d > "$test_decrypt"; then
                log "ERROR" "Test decryption failed - encrypted file is corrupted"
                rm -f "$snapshot_file" "$encrypted_file" "$test_decrypt"
                return 1
            fi
            
            # Verify decrypted content matches original
            local decrypted_checksum=$(sha256sum "$test_decrypt" | cut -d' ' -f1)
            rm -f "$test_decrypt"
            
            if [ "$snapshot_checksum" != "$decrypted_checksum" ]; then
                log "ERROR" "Encryption validation FAILED: checksum mismatch after decrypt"
                log "ERROR" "Original:  $snapshot_checksum"
                log "ERROR" "Decrypted: $decrypted_checksum"
                rm -f "$snapshot_file" "$encrypted_file"
                return 1
            fi
            log "INFO" "✓ Encryption validation PASSED (checksums match)"
            
            final_file="$encrypted_file"
            s3_suffix=".kms"
            ;;
            
        symmetric)
            log "INFO" "Encrypting snapshot with OpenSSL AES-256-CBC..."
            local enc_file="${snapshot_file}.enc"
            if ! openssl enc -aes-256-cbc -salt -pbkdf2 -iter 100000 \
                -in "$snapshot_file" -out "$enc_file" \
                -pass pass:"$BACKUP_PASSWORD"; then
                log "ERROR" "OpenSSL encryption failed"
                rm -f "$snapshot_file"
                return 1
            fi
            
            # Verify encrypted file exists and has content
            if [ ! -s "$enc_file" ]; then
                log "ERROR" "Encrypted file is empty or missing"
                rm -f "$snapshot_file" "$enc_file"
                return 1
            fi
            log "INFO" "✓ Encrypted file created: $(stat -f%z "$enc_file" 2>/dev/null || stat -c%s "$enc_file") bytes"
            
            # Test decrypt to verify encryption integrity
            log "INFO" "Validating encryption (test decrypt)..."
            local test_decrypt="/tmp/etcd-decrypt-test-$$.db"
            if ! openssl enc -aes-256-cbc -d -pbkdf2 -iter 100000 \
                -in "$enc_file" -out "$test_decrypt" \
                -pass pass:"$BACKUP_PASSWORD"; then
                log "ERROR" "Test decryption failed - encrypted file is corrupted"
                rm -f "$snapshot_file" "$enc_file" "$test_decrypt"
                return 1
            fi
            
            # Verify decrypted content matches original
            local decrypted_checksum=$(sha256sum "$test_decrypt" | cut -d' ' -f1)
            rm -f "$test_decrypt"
            
            if [ "$snapshot_checksum" != "$decrypted_checksum" ]; then
                log "ERROR" "Encryption validation FAILED: checksum mismatch after decrypt"
                log "ERROR" "Original:  $snapshot_checksum"
                log "ERROR" "Decrypted: $decrypted_checksum"
                rm -f "$snapshot_file" "$enc_file"
                return 1
            fi
            log "INFO" "✓ Encryption validation PASSED (checksums match)"
            
            final_file="$enc_file"
            s3_suffix=".enc"
            ;;
            
        none)
            log "WARN" "No encryption - uploading plain snapshot (not recommended)"
            final_file="$snapshot_file"
            s3_suffix=""
            ;;
            
        *)
            log "ERROR" "Unknown encryption method: $ENCRYPTION_METHOD"
            rm -f "$snapshot_file"
            return 1
            ;;
    esac
    
    # Calculate final file checksum
    local final_checksum=$(sha256sum "$final_file" | cut -d' ' -f1)
    log "INFO" "Final file checksum: $final_checksum"
    
    # Upload to S3
    local s3_path="${S3_PREFIX}${year}/${month}/$(basename ${snapshot_file})${s3_suffix}"
    log "INFO" "Uploading backup to S3: s3://${S3_BUCKET}/${s3_path}"
    
    if ! {{ bin_dir }}/aws s3 cp "$final_file" \
        "s3://${S3_BUCKET}/${s3_path}" \
        --metadata "backup-timestamp=${timestamp},snapshot-checksum=${snapshot_checksum},encrypted-checksum=${final_checksum}"; then
        log "ERROR" "Failed to upload backup to S3"
        rm -f "$snapshot_file" "$final_file"
        return 1
    fi
    log "INFO" "✓ Upload completed"
    
    # Verify upload
    log "INFO" "Verifying upload..."
    if ! verify_s3_file "$s3_path"; then
        log "ERROR" "Upload verification failed - file not found on S3"
        rm -f "$snapshot_file" "$final_file"
        return 1
    fi
    
    # Download and verify checksum
    log "INFO" "Verifying uploaded file integrity..."
    if ! verify_s3_checksum "$s3_path" "$final_checksum"; then
        log "ERROR" "Upload verification failed - checksum mismatch"
        rm -f "$snapshot_file" "$final_file"
        return 1
    fi
    log "INFO" "✓ Upload verification PASSED"
    
    # Update latest pointer
    log "INFO" "Updating 'latest' pointer..."
    if ! {{ bin_dir }}/aws s3 cp "$final_file" \
        "s3://${S3_BUCKET}/${S3_PREFIX}latest-snapshot.db${s3_suffix}" \
        --metadata "backup-timestamp=${timestamp},snapshot-checksum=${snapshot_checksum},encrypted-checksum=${final_checksum},retention=long-term"; then
        log "WARN" "Failed to update latest pointer (non-fatal)"
    else
        log "INFO" "✓ Latest pointer updated"
    fi
    
    # Tag backup for retention
    log "INFO" "Tagging backup for retention policy..."
    {{ bin_dir }}/aws s3api put-object-tagging \
        --bucket "$S3_BUCKET" \
        --key "$s3_path" \
        --tagging "TagSet=[{Key=Type,Value=etcd-snapshot},{Key=Cluster,Value=${CLUSTER_NAME}},{Key=Timestamp,Value=${timestamp}},{Key=Retention,Value=long-term},{Key=Latest,Value=true}]" \
        >/dev/null 2>&1 || log "WARN" "Failed to set S3 tags (non-fatal)"
    
    # Keep local unencrypted snapshot
    log "INFO" "Saving local copy..."
    if ! cp "$snapshot_file" "${BACKUP_DIR}/${CLUSTER_NAME}-snapshot.db"; then
        log "WARN" "Failed to save local copy (non-fatal)"
    else
        log "INFO" "✓ Local copy saved"
    fi
    
    # Cleanup encrypted file
    log "INFO" "Cleaning up temporary files..."
    if [ "$final_file" != "$snapshot_file" ]; then
        rm -f "$final_file"
    fi
    log "INFO" "✓ Cleanup completed"
    
    log "INFO" "========================================"
    log "INFO" "Snapshot SUCCESS: s3://${S3_BUCKET}/${s3_path}"
    log "INFO" "Snapshot checksum: $snapshot_checksum"
    log "INFO" "Encrypted checksum: $final_checksum"
    log "INFO" "========================================"
    
    return 0
}

# Cleanup old backups
cleanup_old_backups() {
    log "INFO" "Cleaning up local backups older than ${RETENTION_DAYS} days..."
    
    local deleted_count=0
    while IFS= read -r file; do
        log "INFO" "Deleting old backup: $file"
        rm -f "$file"
        ((deleted_count++))
    done < <(find "$BACKUP_DIR" -type f -name "*.db" -mtime "+${RETENTION_DAYS}")
    
    log "INFO" "Deleted $deleted_count old backup(s)"
    
    # Cleanup empty directories
    find "$BACKUP_DIR" -type d -empty -delete
    log "INFO" "✓ Local cleanup completed"
}

# Check if recent backup exists in S3
check_recent_backup() {
    local interval_seconds={{ (etcd_backup_interval | replace('*/', '') | replace('*/','') | int) * 60 }}
    local current_time=$(date +%s)
    local cutoff_time=$((current_time - interval_seconds))
    
    log "INFO" "Checking for recent backups (within last {{ etcd_backup_interval }} minutes)..."
    
    # List recent backups from S3
    local recent_backups=$({{ bin_dir }}/aws s3api list-objects-v2 \
        --bucket "$S3_BUCKET" \
        --prefix "${S3_PREFIX}" \
        --query "Contents[?LastModified>=\`$(date -u -d @${cutoff_time} '+%Y-%m-%dT%H:%M:%S')\`].{Key:Key,Modified:LastModified}" \
        --output text 2>/dev/null || echo "")
    
    if [ -n "$recent_backups" ]; then
        log "INFO" "Recent backup found (created by another node):"
        echo "$recent_backups" | while read key modified; do
            log "INFO" "  - s3://${S3_BUCKET}/${key} (${modified})"
        done
        return 0  # Recent backup exists
    else
        log "INFO" "No recent backup found, proceeding with backup creation"
        return 1  # No recent backup
    fi
}

# Main logic
main() {
    log "INFO" "========================================"
    log "INFO" "Etcd Backup Script Starting"
    log "INFO" "Time: $(date '+%Y-%m-%d %H:%M:%S')"
    log "INFO" "Node: {{ inventory_hostname }}"
    log "INFO" "Cluster: $CLUSTER_NAME"
    log "INFO" "Endpoints: $ETCD_ENDPOINTS"
    log "INFO" "Encryption: $ENCRYPTION_METHOD"
    log "INFO" "S3 Bucket: s3://${S3_BUCKET}/${S3_PREFIX}${CLUSTER_NAME}"
    log "INFO" "Distributed backup: {{ etcd_backup_distributed | default(true) }}"
    log "INFO" "Force backup: $FORCE_BACKUP"
    log "INFO" "Dry run: $DRY_RUN"
    log "INFO" "========================================"
    
    # Check etcd health
    log "INFO" "Checking etcd cluster health..."
    if {{ bin_dir }}/etcdctl --endpoints="$ETCD_ENDPOINTS" \
        --cert="$CERT" --cacert="$CACERT" --key="$KEY" \
        endpoint health > /dev/null 2>&1; then
        log "INFO" "✓ Etcd cluster is healthy"
    else
        if [ "$FORCE_BACKUP" = true ]; then
            log "WARN" "Etcd cluster is unhealthy, but force backup requested"
        else
            log "ERROR" "Etcd cluster is unhealthy, aborting backup"
            log "ERROR" "Use --force to backup anyway (may result in inconsistent data)"
            
            # Send healthcheck ping for failure
            if [ -n "$HEALTHCHECK_URL" ]; then
                curl -fsS --retry 3 "${HEALTHCHECK_URL}?status=cluster-unhealthy" > /dev/null 2>&1 || true
            fi
            
            return 1
        fi
    fi
    
    # Check for recent backups (distributed backup coordination)
{% if etcd_backup_distributed | default(true) and not etcd_backup_independent | default(false) %}
    if [ "$FORCE_BACKUP" != true ] && [ "$INDEPENDENT_MODE" != true ]; then
        if check_recent_backup; then
            log "INFO" "========================================"
            log "INFO" "Recent backup already exists (created by another node)"
            log "INFO" "Skipping backup to avoid duplicates"
            log "INFO" "This is expected behavior in distributed backup mode"
            log "INFO" "========================================"
            
            # Send healthcheck ping for "backup exists" status
            if [ -n "$HEALTHCHECK_URL" ]; then
                curl -fsS --retry 3 "${HEALTHCHECK_URL}?status=backup-exists" > /dev/null 2>&1 || \
                    log "WARN" "Healthcheck ping failed (non-fatal)"
            fi
            
            return 0  # Success - backup exists
        fi
    fi
{% endif %}
{% if etcd_backup_independent | default(false) %}
    if [ "$FORCE_BACKUP" != true ]; then
        log "INFO" "========================================"
        log "INFO" "INDEPENDENT MODE: Creating backup without checking for existing backups"
        log "INFO" "Multiple backups will be created (one per node)"
        log "INFO" "========================================"
    fi
{% endif %}
    
    # Create snapshot
    log "INFO" "Starting snapshot operation..."
    if create_snapshot; then
        if [ "$DRY_RUN" = false ]; then
            # Cleanup old backups
            cleanup_old_backups
        fi
        
        # Send healthcheck ping if configured
        if [ -n "$HEALTHCHECK_URL" ] && [ "$DRY_RUN" = false ]; then
            log "INFO" "Sending healthcheck ping..."
            if curl -fsS --retry 3 "${HEALTHCHECK_URL}?status=success" > /dev/null 2>&1; then
                log "INFO" "✓ Healthcheck ping successful"
            else
                log "WARN" "Healthcheck ping failed (non-fatal)"
            fi
        fi
        
        log "INFO" "========================================"
        log "INFO" "Etcd Backup Completed Successfully"
        log "INFO" "========================================"
        return 0
    else
        log "ERROR" "========================================"
        log "ERROR" "Etcd Backup FAILED"
        log "ERROR" "========================================"
        
        # Send healthcheck ping for failure
        if [ -n "$HEALTHCHECK_URL" ] && [ "$DRY_RUN" = false ]; then
            curl -fsS --retry 3 "${HEALTHCHECK_URL}?status=failure" > /dev/null 2>&1 || true
        fi
        
        return 1
    fi
}

export ETCDCTL_API=3
main "$@"
