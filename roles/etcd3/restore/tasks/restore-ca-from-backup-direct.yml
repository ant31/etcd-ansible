---
# Direct CA restore from S3 backup - used during replication
# Simpler than full restore-ca.yml (no confirmation, no existing backup)
# Variables required:
#   - restore_ca_from: s3
#   - restore_ca_s3_file: S3 path or 'latest'

- name: Confirm force CA replacement on ALL cert-managers (DANGEROUS - requires explicit confirmation)
  pause:
    prompt: |
      âš ï¸  EXTREME WARNING: FORCE CA REPLACEMENT ON ALL CERT-MANAGERS
      
      You have set etcd_force_ca_replacement=true
      This will DELETE the CA on ALL cert-managers (including PRIMARY)!
      
      Affected nodes:
      {% for host in groups[etcd_certmanagers_group] %}  - {{ host }}{% if host == groups[etcd_certmanagers_group][0] %} (PRIMARY - step-ca RUNNING){% else %} (backup){% endif %}
      {% endfor %}
      
      This is EXTREMELY RARE and only used for:
      - Complete CA rebuild during disaster recovery
      - Replacing compromised CA on ALL nodes
      
      Normal operations use:
      - etcd_force_ca_replication=true (backup nodes only)
      - step_ca_force_cleanup=true (cleanup only)
      
      Are you ABSOLUTELY SURE? Type 'yes-force-replace-all' to continue
  register: force_ca_replacement_confirm
  when:
    - etcd_force_ca_replacement | default(false) | bool
    - restore_confirm | default(true) | bool
  run_once: true
  tags:
    - restore-ca

- name: Validate force CA replacement confirmation
  assert:
    that:
      - not (etcd_force_ca_replacement | default(false) | bool and restore_confirm | default(true) | bool) or (force_ca_replacement_confirm.user_input is defined and force_ca_replacement_confirm.user_input == 'yes-force-replace-all')
    fail_msg: "âŒ Force CA replacement cancelled: user did not confirm with 'yes-force-replace-all' (entered: '{{ force_ca_replacement_confirm.user_input | default('no input') }}')"
  when:
    - etcd_force_ca_replacement | default(false) | bool
    - restore_confirm | default(true) | bool
  run_once: true
  tags:
    - restore-ca

- name: Display warning about force CA replacement scope
  debug:
    msg:
      - "âš ï¸  WARNING: etcd_force_ca_replacement=true is active"
      - ""
      - "This affects ALL cert-managers (including primary):"
      - "{% for host in groups[etcd_certmanagers_group] %}  - {{ host }}{% endfor %}"
      - ""
      - "Normal replication only affects backup nodes (cert-managers[1:])."
      - "This is a DISASTER RECOVERY operation."
  when:
    - etcd_force_ca_replacement | default(false) | bool
  run_once: true
  tags:
    - restore-ca

- name: Stop step-ca service if running (cleanup on backup cert-managers when force replication OR force cleanup)
  systemd:
    name: step-ca
    state: stopped
  failed_when: false
  when:
    - inventory_hostname in groups[etcd_certmanagers_group][1:]
    - step_ca_force_cleanup | default(false) | bool or etcd_force_ca_replication | default(false) | bool
  tags:
    - restore-ca

- name: Kill any running step-ca processes (force cleanup on backup cert-managers when force replication OR force cleanup)
  shell: |
    # Kill step-ca processes
    pkill -9 step-ca || true
    
    # Wait for processes to fully terminate
    sleep 2
    
    # Clean up any leftover step-ca temporary files
    rm -rf /tmp/step-ca-* 2>/dev/null || true
    rm -rf /var/tmp/step-ca-* 2>/dev/null || true
  when:
    - inventory_hostname in groups[etcd_certmanagers_group][1:]
    - step_ca_force_cleanup | default(false) | bool or etcd_force_ca_replication | default(false) | bool
  tags:
    - restore-ca

- name: Remove entire step-ca directory for clean restore (prevents key mismatch errors on backup cert-managers)
  file:
    path: /etc/step-ca
    state: absent
  when:
    - inventory_hostname in groups[etcd_certmanagers_group][1:]
    - step_ca_force_cleanup | default(false) | bool or etcd_force_ca_replication | default(false) | bool
  tags:
    - restore-ca

- name: Clean step-ca log files (prevents key mismatch errors on backup cert-managers)
  find:
    paths: /var/log
    patterns: "step-ca*.log"
    file_type: file
  register: step_ca_log_files
  when:
    - inventory_hostname in groups[etcd_certmanagers_group][1:]
    - step_ca_force_cleanup | default(false) | bool or etcd_force_ca_replication | default(false) | bool
  tags:
    - restore-ca

- name: Remove step-ca log files
  file:
    path: "{{ item.path }}"
    state: absent
  loop: "{{ step_ca_log_files.files | default([]) }}"
  loop_control:
    label: "{{ item.path }}"
  when:
    - inventory_hostname in groups[etcd_certmanagers_group][1:]
    - step_ca_force_cleanup | default(false) | bool or etcd_force_ca_replication | default(false) | bool
    - step_ca_log_files.files is defined
  tags:
    - restore-ca

- name: Display cleanup status
  debug:
    msg:
      - "{% if step_ca_force_cleanup | default(false) | bool or etcd_force_ca_replication | default(false) | bool %}âœ… step-ca cleanup completed on backup cert-manager{% else %}â­ï¸  step-ca cleanup SKIPPED (neither step_ca_force_cleanup nor etcd_force_ca_replication set){% endif %}"
      - ""
      - "Triggered by: {% if step_ca_force_cleanup | default(false) | bool %}step_ca_force_cleanup{% elif etcd_force_ca_replication | default(false) | bool %}etcd_force_ca_replication{% else %}NONE{% endif %}"
      - ""
      - "Cleanup includes:"
      - "- Stopped step-ca service"
      - "- Killed running processes"
      - "- Removed badger database (/etc/step-ca/db)"
      - "- Cleaned cache and temp files"
      - ""
      - "This prevents 'PrivateKey doesn't match parent's PublicKey' errors."
      - ""
      - "To enable cleanup during deploy:"
      - "  ansible-playbook -i inventory.ini etcd.yaml -e etcd_action=deploy -e etcd_force_ca_replication=true -b"
      - "  OR"
      - "  ansible-playbook -i inventory.ini etcd.yaml -e etcd_action=deploy -e step_ca_force_cleanup=true -b"
  when: inventory_hostname in groups[etcd_certmanagers_group][1:]
  tags:
    - restore-ca

- name: Find latest CA backup in S3 (exclude .sha256 files)
  shell: >
    {{ bin_dir }}/aws s3api list-objects-v2
    --bucket {{ step_ca_backup_s3_bucket }}
    --prefix {{ step_ca_backup_s3_prefix }}/
    --query 'Contents[?!contains(Key, `latest-ca-backup`) && !ends_with(Key, `.sha256`)] | reverse(sort_by(@, &LastModified))[0].Key'
    --output text 2>/dev/null || echo "NONE"
  environment:
    AWS_ACCESS_KEY_ID: "{{ aws_access_key_id | default('') }}"
    AWS_SECRET_ACCESS_KEY: "{{ aws_secret_access_key | default('') }}"
    AWS_DEFAULT_REGION: "{{ aws_default_region | default('us-east-1') }}"
  register: latest_backup
  when: restore_ca_s3_file == 'latest'
  changed_when: false
  failed_when: false
  tags:
    - restore-ca

- name: Check if CA backup exists
  set_fact:
    ca_backup_exists: "{{ latest_backup.stdout is defined and latest_backup.stdout != 'NONE' and latest_backup.stdout != 'None' and latest_backup.stdout | length > 0 }}"
  when: restore_ca_s3_file == 'latest'
  tags:
    - restore-ca

- name: Ensure backup tmp restore directory exists
  file:
    path: "{{ backup_tmp_dir | default('/opt/backups/tmp') }}/restore"
    state: directory
    owner: root
    group: root
    mode: 0700
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Display warning if no backup exists
  debug:
    msg:
      - "âš ï¸  No CA backup found in S3 (initial deployment)"
      - ""
      - "Bucket: s3://{{ step_ca_backup_s3_bucket }}/{{ step_ca_backup_s3_prefix }}/"
      - ""
      - "This is expected during initial cluster deployment."
      - "CA replication will be skipped for this backup cert-manager."
      - ""
      - "The CA backup is being created now and will be available soon."
      - ""
      - "To manually replicate CA later:"
      - "  ansible-playbook -i inventory.ini playbooks/replicate-ca.yaml"
  when: 
    - restore_ca_s3_file == 'latest'
    - not ca_backup_exists | default(false)
  tags:
    - restore-ca

- name: End play if no backup exists
  meta: end_host
  when:
    - restore_ca_s3_file == 'latest'
    - not ca_backup_exists | default(false)
  tags:
    - restore-ca

- name: Set backup file path
  set_fact:
    ca_backup_s3_path: "{{ restore_ca_s3_file if restore_ca_s3_file != 'latest' else latest_backup.stdout }}"
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Detect encryption method from backup file
  set_fact:
    backup_encryption_method: >-
      {%- if ca_backup_s3_path.endswith('.kms') -%}
      aws-kms
      {%- elif ca_backup_s3_path.endswith('.enc') -%}
      symmetric
      {%- else -%}
      none
      {%- endif -%}
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Set backup filename from S3 path
  set_fact:
    ca_backup_filename: "{{ ca_backup_s3_path | basename }}"
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Display backup restore plan
  debug:
    msg:
      - "ðŸ“¥ Restoring CA from S3 backup"
      - ""
      - "Node: {{ inventory_hostname }}"
      - "S3 path: s3://{{ step_ca_backup_s3_bucket }}/{{ ca_backup_s3_path }}"
      - "Filename: {{ ca_backup_filename }}"
      - "Encryption: {{ backup_encryption_method }}"
      - "Force replace existing CA: {{ etcd_force_ca_replacement | default(true) }}"
      - ""
      - "This backup should match primary cert-manager: {{ groups[etcd_certmanagers_group][0] }}"
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Download CA backup from S3 (preserving filename)
  command: >
    {{ bin_dir }}/aws s3 cp
    s3://{{ step_ca_backup_s3_bucket }}/{{ ca_backup_s3_path }}
    {{ backup_tmp_dir | default('/opt/backups/tmp') }}/restore/{{ ca_backup_filename }}
  environment:
    PATH: "{{ bin_dir }}:{{ ansible_env.PATH }}"
    AWS_ACCESS_KEY_ID: "{{ aws_access_key_id | default('') }}"
    AWS_SECRET_ACCESS_KEY: "{{ aws_secret_access_key | default('') }}"
    AWS_DEFAULT_REGION: "{{ aws_default_region | default('us-east-1') }}"
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Decrypt CA backup using backup script (handles envelope encryption)
  command: >
    /usr/bin/python3 {{ backup_scripts_dir }}/ca-backup-check.py
    --config {{ ca_backup_config_file }}
    --decrypt
    --input {{ backup_tmp_dir | default('/opt/backups/tmp') }}/restore/{{ ca_backup_filename }}
    --output {{ backup_tmp_dir | default('/opt/backups/tmp') }}/restore/ca-restore.tar.gz
    --encryption {{ backup_encryption_method }}
  register: decrypt_result
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Display decryption result
  debug:
    msg: "{{ decrypt_result.stdout_lines }}"
  when: 
    - decrypt_result is defined
    - decrypt_result is changed
  tags:
    - restore-ca


- name: Remove existing CA directories before restore (replacement or replication)
  file:
    path: "{{ item }}"
    state: absent
  loop:
    - /etc/step-ca/secrets
    - /etc/step-ca/certs
    - /etc/step-ca/config
    - /etc/step-ca/db
  when:
    - ca_backup_exists | default(true) | bool
    - |
      etcd_force_ca_replacement | default(false) | bool or
      (inventory_hostname in groups[etcd_certmanagers_group][1:] and etcd_force_ca_replication | default(true) | bool)
  tags:
    - restore-ca

- name: Display CA directory cleanup status
  debug:
    msg:
      - "âœ… Existing CA directories cleaned on {{ inventory_hostname }}"
      - ""
      - "Deleted CA directories:"
      - "  - /etc/step-ca/secrets (private keys)"
      - "  - /etc/step-ca/certs (certificates)"
      - "  - /etc/step-ca/config (configuration)"
      - "  - /etc/step-ca/db (database)"
      - ""
      - "Triggered by: {% if etcd_force_ca_replacement | default(false) | bool %}DISASTER RECOVERY (etcd_force_ca_replacement=true) - CAN affect ALL cert-managers{% else %}NORMAL REPLICATION (etcd_force_ca_replication=true) - backup cert-managers only{% endif %}"
      - "This node's CA will be completely replaced from S3 backup."
      - "{% if inventory_hostname == groups[etcd_certmanagers_group][0] %}âš ï¸  This is the PRIMARY cert-manager (disaster recovery mode){% else %}âœ“ This is a backup cert-manager{% endif %}"
  when:
    - ca_backup_exists | default(true) | bool
    - |
      etcd_force_ca_replacement | default(false) | bool or
      (inventory_hostname in groups[etcd_certmanagers_group][1:] and etcd_force_ca_replication | default(true) | bool)
  tags:
    - restore-ca

- name: Ensure step-ca directories exist (root only)
  file:
    path: "{{ item }}"
    state: directory
    owner: root
    group: root
    mode: 0700
  loop:
    - /etc/step-ca/secrets
    - /etc/step-ca/certs
    - /etc/step-ca/config
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Extract CA backup
  unarchive:
    src: "{{ backup_tmp_dir | default('/opt/backups/tmp') }}/restore/ca-restore.tar.gz"
    dest: /
    remote_src: yes
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Set CA file permissions (root only, step-ca runs as root)
  file:
    path: /etc/step-ca/secrets
    state: directory
    owner: root
    group: root
    mode: 0700
    recurse: yes
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Set CA private key permissions (root only, 0400)
  shell: |
    find /etc/step-ca/secrets -type f -name "*_key" -exec chmod 0400 {} \;
    find /etc/step-ca/secrets -type f -name "*_key" -exec chown root:root {} \;
    if [ -f /etc/step-ca/secrets/password ]; then
      chmod 0400 /etc/step-ca/secrets/password
    fi
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Get restored CA fingerprint for verification
  shell: >
    {{ bin_dir }}/step certificate fingerprint /etc/step-ca/certs/root_ca.crt
  register: restored_ca_fingerprint
  changed_when: false
  failed_when: false
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Display restore completion
  debug:
    msg:
      - "âœ… CA restored from S3 backup"
      - ""
      - "Backup file: {{ ca_backup_filename }}"
      - "Restored CA fingerprint: {{ restored_ca_fingerprint.stdout | default('ERROR - could not read') }}"
      - ""
      - "This fingerprint should match primary: {{ groups[etcd_certmanagers_group][0] }}"
      - "Verification will happen in next task..."
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca

- name: Cleanup temporary files
  file:
    path: "{{ backup_tmp_dir | default('/opt/backups/tmp') }}/restore"
    state: absent
  when: ca_backup_exists | default(true) | bool
  tags:
    - restore-ca
