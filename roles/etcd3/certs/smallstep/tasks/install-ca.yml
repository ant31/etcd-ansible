---
- name: Create step-ca directories (owned by root, step-ca runs as root)
  file:
    path: "{{ item }}"
    state: directory
    owner: root
    group: root
    mode: 0700
  loop:
    - "{{ step_path }}"
    - "{{ step_path }}/config"
    - "{{ step_ca_db }}"
    - "{{ step_ca_certs }}"
    - "{{ step_ca_secrets }}"

- name: Check if step-ca is installed
  stat:
    path: "{{ bin_dir }}/step-ca"
  register: step_ca_installed

- name: Fail if step-ca binary not installed
  fail:
    msg: |
      ❌ step-ca binary not found
      Expected location: {{ bin_dir }}/step-ca
      
      The download role should have installed this already.
      
      Manual installation:
         curl -L -o /tmp/step-ca.tar.gz https://github.com/smallstep/certificates/releases/download/v{{ step_ca_version }}/step-ca_linux_{{ step_ca_version }}_amd64.tar.gz
         tar -xzf /tmp/step-ca.tar.gz -C /tmp
         cp /tmp/step-ca {{ bin_dir }}/step-ca
         chmod 755 {{ bin_dir }}/step-ca
  when: not step_ca_installed.stat.exists

- name: Check if step CLI is installed
  stat:
    path: "{{ bin_dir }}/step"
  register: step_cli_installed

- name: Fail if step CLI binary not installed
  fail:
    msg: |
      ❌ step CLI binary not found
      Expected location: {{ bin_dir }}/step
      
      The download role should have installed this already.
      
      Manual installation:
         curl -L -o /tmp/step.tar.gz https://github.com/smallstep/cli/releases/download/v{{ step_version }}/step_linux_{{ step_version }}_amd64.tar.gz
         tar -xzf /tmp/step.tar.gz -C /tmp
         cp /tmp/step_{{ step_version }}/bin/step {{ bin_dir }}/step
         chmod 755 {{ bin_dir }}/step
  when: not step_cli_installed.stat.exists

- name: Check if CA already initialized
  stat:
    path: "{{ step_ca_config }}"
  register: step_ca_config_stat

- name: Initialize step-ca
  shell: |
    {{ bin_dir }}/step ca init \
      --name="{{ step_ca_name }}" \
      --dns="{{ step_ca_dns }}" \
      --address=":{{ step_ca_port }}" \
      --provisioner="{{ step_ca_provisioner }}" \
      --password-file=<(echo "{{ step_ca_password }}") \
      --provisioner-password-file=<(echo "{{ step_provisioner_password }}") \
      --dns="127.0.0.1" \
      --dns="localhost"
  args:
    executable: /bin/bash
  environment:
    STEPPATH: "{{ step_path }}"
  when: not step_ca_config_stat.stat.exists

- name: Configure step-ca certificate durations
  shell: |
    /usr/bin/env python3 -c "
    import json
    import sys
    
    path = '{{ step_ca_config }}'
    with open(path, 'r') as f:
        config = json.load(f)
    
    updated = False
    for p in config.get('authority', {}).get('provisioners', []):
        if p.get('name') == '{{ step_ca_provisioner }}':
            p['claims'] = {
                'minTLSCertDuration': '{{ step_cert_min_duration }}',
                'maxTLSCertDuration': '{{ step_cert_max_duration }}',
                'defaultTLSCertDuration': '{{ step_cert_default_duration }}'
            }
            updated = True
    
    if updated:
        with open(path, 'w') as f:
            json.dump(config, f, indent=4)
    else:
        print('Provisioner {{ step_ca_provisioner }} not found in config')
        sys.exit(1)
    "
  when: not step_ca_config_stat.stat.exists

- name: Create step-ca systemd service
  template:
    src: step-ca.service.j2
    dest: /etc/systemd/system/step-ca.service
    mode: 0644
  notify: restart step-ca

- name: Create step-ca password file
  copy:
    content: "{{ step_ca_password }}"
    dest: "{{ step_ca_secrets }}/password"
    owner: root
    group: root
    mode: 0400

- name: Fix ownership and permissions of ALL CA files (step-ca runs as root)
  file:
    path: "{{ item.path }}"
    owner: root
    group: root
    mode: "{{ item.mode }}"
    state: "{{ item.state }}"
    recurse: "{{ item.recurse | default(false) }}"
  loop:
    - { path: "{{ step_path }}", mode: "0755", state: "directory", recurse: false }
    - { path: "{{ step_ca_secrets }}", mode: "0700", state: "directory", recurse: false }
    - { path: "{{ step_ca_certs }}", mode: "0755", state: "directory", recurse: false }
    - { path: "{{ step_ca_config }}", mode: "0640", state: "file" }
    - { path: "{{ step_ca_db }}", mode: "0700", state: "directory", recurse: false }
  loop_control:
    label: "{{ item.path }}"

- name: Fix CA secrets files permissions (private keys - root only)
  file:
    path: "{{ item }}"
    owner: root
    group: root
    mode: 0400
  loop:
    - "{{ step_ca_secrets }}/root_ca_key"
    - "{{ step_ca_secrets }}/intermediate_ca_key"
    - "{{ step_ca_secrets }}/password"
  failed_when: false

- name: Fix CA certificate permissions (root only, NOT world-readable)
  file:
    path: "{{ item }}"
    owner: root
    group: root
    mode: 0400
  loop:
    - "{{ step_ca_certs }}/root_ca.crt"
    - "{{ step_ca_certs }}/intermediate_ca.crt"
  failed_when: false

- name: Enable and start step-ca service
  systemd:
    name: step-ca
    enabled: yes
    state: started
    daemon_reload: yes
  register: step_ca_service

- name: Check step-ca service status
  command: systemctl status step-ca
  register: step_ca_status
  failed_when: false
  changed_when: false

- name: Show step-ca service status if it failed to start
  debug:
    var: step_ca_status.stdout_lines
  when: step_ca_service.state != 'started'

- name: Show step-ca logs if service failed
  command: journalctl -u step-ca -n 50 --no-pager
  register: step_ca_logs
  when: step_ca_service.state != 'started'
  failed_when: false
  changed_when: false

- name: Display step-ca logs on failure
  debug:
    var: step_ca_logs.stdout_lines
  when: step_ca_service.state != 'started'

- name: Wait for step-ca to be ready (localhost check)
  uri:
    url: "https://localhost:{{ step_ca_port }}/health"
    validate_certs: no
    status_code: 200
  register: result
  until: result.status == 200
  retries: 10
  delay: 3

- name: Get root CA certificate
  slurp:
    src: "{{ step_ca_certs }}/root_ca.crt"
  register: step_root_ca
  
- name: Store root CA as fact
  set_fact:
    step_ca_root_cert: "{{ step_root_ca.content | b64decode }}"
  delegate_to: "{{ item }}"
  delegate_facts: true
  loop: "{{ groups[etcd_cluster_group] + groups[etcd_clients_group] }}"

- name: Replicate CA keys to backup cert-managers
  block:
    - name: Read CA private keys for replication
      slurp:
        src: "{{ item }}"
      register: ca_keys_for_replication
      loop:
        - "{{ step_ca_secrets }}/root_ca_key"
        - "{{ step_ca_secrets }}/intermediate_ca_key"
        - "{{ step_ca_secrets }}/password"
      no_log: true

    - name: Read CA config for replication
      slurp:
        src: "{{ step_ca_config }}"
      register: ca_config_for_replication

    - name: Install CA keys on backup cert-managers (root only)
      copy:
        content: "{{ item.1.content | b64decode }}"
        dest: "{{ item.1.source }}"
        owner: root
        group: root
        mode: 0400
      delegate_to: "{{ item.0 }}"
      loop: "{{ groups[etcd_certmanagers_group][1:] | product(ca_keys_for_replication.results) | list }}"
      loop_control:
        label: "{{ item.0 }}: {{ item.1.source | basename }}"
      when: groups[etcd_certmanagers_group] | length > 1

    - name: Install CA config on backup cert-managers (root only)
      copy:
        content: "{{ ca_config_for_replication.content | b64decode }}"
        dest: "{{ step_ca_config }}"
        owner: root
        group: root
        mode: 0640
      delegate_to: "{{ item }}"
      loop: "{{ groups[etcd_certmanagers_group][1:] }}"
      when: groups[etcd_certmanagers_group] | length > 1

    - name: Ensure step-ca is stopped on backup cert-managers
      systemd:
        name: step-ca
        enabled: no
        state: stopped
      delegate_to: "{{ item }}"
      loop: "{{ groups[etcd_certmanagers_group][1:] }}"
      when: groups[etcd_certmanagers_group] | length > 1

    - name: Display HA configuration status
      debug:
        msg: "HA configured - CA keys replicated to {{ groups[etcd_certmanagers_group][1:] | join(', ') }}"
      when: groups[etcd_certmanagers_group] | length > 1

  when:
    - groups[etcd_certmanagers_group] | length > 1
    - inventory_hostname == groups[etcd_certmanagers_group][0]
