---
- name: Create step-ca directories (owned by root, step-ca runs as root)
  file:
    path: "{{ item }}"
    state: directory
    owner: root
    group: root
    mode: 0700
  loop:
    - "{{ step_path }}"
    - "{{ step_path }}/config"
    - "{{ step_ca_db }}"
    - "{{ step_ca_certs }}"
    - "{{ step_ca_secrets }}"

- name: Check if step-ca is installed
  stat:
    path: "{{ bin_dir }}/step-ca"
  register: step_ca_installed

- name: Fail if step-ca binary not installed
  fail:
    msg:
      - "‚ùå step-ca binary not found"
      - "Expected location: {{ bin_dir }}/step-ca"
      - ""
      - "The download role should have installed this already."
      - ""
      - "Manual installation:"
      - "   curl -L -o /tmp/step-ca.tar.gz https://github.com/smallstep/certificates/releases/download/v{{ step_ca_version }}/step-ca_linux_{{ step_ca_version }}_amd64.tar.gz"
      - "   tar -xzf /tmp/step-ca.tar.gz -C /tmp"
      - "   cp /tmp/step-ca {{ bin_dir }}/step-ca"
      - "   chmod 755 {{ bin_dir }}/step-ca"
  when: not step_ca_installed.stat.exists

- name: Check if step CLI is installed
  stat:
    path: "{{ bin_dir }}/step"
  register: step_cli_installed

- name: Fail if step CLI binary not installed
  fail:
    msg:
      - "‚ùå step CLI binary not found"
      - "Expected location: {{ bin_dir }}/step"
      - ""
      - "The download role should have installed this already."
      - ""
      - "Manual installation:"
      - "   curl -L -o /tmp/step.tar.gz https://github.com/smallstep/cli/releases/download/v{{ step_version }}/step_linux_{{ step_version }}_amd64.tar.gz"
      - "   tar -xzf /tmp/step.tar.gz -C /tmp"
      - "   cp /tmp/step_{{ step_version }}/bin/step {{ bin_dir }}/step"
      - "   chmod 755 {{ bin_dir }}/step"
  when: not step_cli_installed.stat.exists

- name: Check if CA already initialized
  stat:
    path: "{{ step_ca_config }}"
  register: step_ca_config_stat

- name: Initialize step-ca
  shell: |
    {{ bin_dir }}/step ca init \
      --name="{{ step_ca_name }}" \
      --dns="{{ step_ca_dns }}" \
      --address=":{{ step_ca_port }}" \
      --provisioner="{{ step_ca_provisioner }}" \
      --password-file=<(echo "{{ step_ca_password }}") \
      --provisioner-password-file=<(echo "{{ step_provisioner_password }}") \
      --dns="127.0.0.1" \
      --dns="localhost"
  args:
    executable: /bin/bash
  environment:
    STEPPATH: "{{ step_path }}"
  when: not step_ca_config_stat.stat.exists

- name: Copy step-ca configuration script
  template:
    src: configure_step_ca_durations.py.j2
    dest: /tmp/configure_step_ca_durations.py
    mode: 0755
  when: not step_ca_config_stat.stat.exists

- name: Configure step-ca certificate durations
  command: /usr/bin/python3 /tmp/configure_step_ca_durations.py
  register: configure_durations_result
  when: not step_ca_config_stat.stat.exists

- name: Display configuration result
  debug:
    msg: "{{ configure_durations_result.stdout_lines | default(['No output']) }}"
  when: 
    - not step_ca_config_stat.stat.exists
    - configure_durations_result is defined

- name: Cleanup configuration script
  file:
    path: /tmp/configure_step_ca_durations.py
    state: absent
  when: not step_ca_config_stat.stat.exists

- name: Create step-ca systemd service
  template:
    src: step-ca.service.j2
    dest: /etc/systemd/system/step-ca.service
    mode: 0644
  notify: restart step-ca

- name: Create step-ca password file
  copy:
    content: "{{ step_ca_password }}"
    dest: "{{ step_ca_secrets }}/password"
    owner: root
    group: root
    mode: 0400

- name: Fix ownership and permissions of ALL CA files (step-ca runs as root)
  file:
    path: "{{ item.path }}"
    owner: root
    group: root
    mode: "{{ item.mode }}"
    state: "{{ item.state }}"
    recurse: "{{ item.recurse | default(false) }}"
  loop:
    - { path: "{{ step_path }}", mode: "0700", state: "directory", recurse: false }
    - { path: "{{ step_ca_secrets }}", mode: "0700", state: "directory", recurse: false }
    - { path: "{{ step_ca_certs }}", mode: "0700", state: "directory", recurse: false }
    - { path: "{{ step_ca_config }}", mode: "0600", state: "file" }
    - { path: "{{ step_ca_db }}", mode: "0700", state: "directory", recurse: false }
  loop_control:
    label: "{{ item.path }}"

- name: Fix CA secrets files permissions (private keys - root only)
  file:
    path: "{{ item }}"
    owner: root
    group: root
    mode: 0400
  loop:
    - "{{ step_ca_secrets }}/root_ca_key"
    - "{{ step_ca_secrets }}/intermediate_ca_key"
    - "{{ step_ca_secrets }}/password"
  failed_when: false

- name: Fix CA certificate permissions (root only, NOT world-readable)
  file:
    path: "{{ item }}"
    owner: root
    group: root
    mode: 0400
  loop:
    - "{{ step_ca_certs }}/root_ca.crt"
    - "{{ step_ca_certs }}/intermediate_ca.crt"
  failed_when: false

# Determine primary cert-manager (first from etcd_cert_managers_all if exists, else first from cluster group)
- name: Determine primary cert-manager for multi-cluster
  set_fact:
    _primary_cert_manager: "{{ groups['etcd_cert_managers_all'][0] if 'etcd_cert_managers_all' in groups else groups[etcd_certmanagers_group][0] }}"
  run_once: true

- name: Enable and restart step-ca service (PRIMARY cert-manager only, refresh runtime timer)
  systemd:
    name: step-ca
    enabled: yes
    state: restarted
    daemon_reload: yes
  when: inventory_hostname == _primary_cert_manager
  register: step_ca_service

- name: Display step-ca runtime configuration
  debug:
    msg:
      - "step-ca runtime limit: {{ 'INFINITE (always running)' if step_ca_runtime_minutes | int == 0 else (step_ca_runtime_minutes | string) + ' minutes' }}"
      - ""
      - "{% if step_ca_runtime_minutes | int > 0 %}Security note: step-ca will automatically stop after {{ step_ca_runtime_minutes }} minutes.{% endif %}"
      - "{% if step_ca_runtime_minutes | int > 0 %}This minimizes attack surface by only running the CA when needed.{% endif %}"
      - ""
      - "Multi-cluster mode: {{ 'ENABLED - This step-ca serves ALL clusters' if 'etcd_all' in groups else 'Single cluster' }}"
      - "Primary cert-manager: {{ _primary_cert_manager }}"
      - "{% if 'etcd_all' in groups %}Clusters served: {{ etcd_cluster_configs.keys() | list | join(', ') }}{% endif %}"
  when: inventory_hostname == _primary_cert_manager

- name: Get all backup cert-managers across all clusters
  set_fact:
    _all_backup_cert_managers: "{{ (groups['etcd_cert_managers_all'][1:] if 'etcd_cert_managers_all' in groups else groups[etcd_certmanagers_group][1:]) | default([]) }}"
  run_once: true

- name: Ensure step-ca is installed but STOPPED on backup cert-managers (before replication)
  systemd:
    name: step-ca
    enabled: no
    state: stopped
    daemon_reload: yes
  when: 
    - inventory_hostname in _all_backup_cert_managers
  failed_when: false

- name: Display backup cert-manager status
  debug:
    msg:
      - "üìã Backup cert-manager configuration"
      - ""
      - "Node: {{ inventory_hostname }}"
      - "Role: BACKUP (step-ca installed but STOPPED)"
      - ""
      - "step-ca will be replicated from primary: {{ _primary_cert_manager }}"
      - "CA replication happens next (encrypted backup/restore method)"
      - "{% if 'etcd_all' in groups %}Multi-cluster: This CA serves all clusters{% endif %}"
  when: inventory_hostname in _all_backup_cert_managers

- name: Check step-ca service status
  command: systemctl status step-ca
  register: step_ca_status
  failed_when: false
  changed_when: false
  when: inventory_hostname == groups[etcd_certmanagers_group][0]

- name: Show step-ca service status if it failed to start
  debug:
    var: step_ca_status.stdout_lines
  when:
    - inventory_hostname == groups[etcd_certmanagers_group][0]
    - step_ca_service.state is defined
    - step_ca_service.state != 'started'

- name: Show step-ca logs if service failed
  command: journalctl -u step-ca -n 50 --no-pager
  register: step_ca_logs
  when:
    - inventory_hostname == groups[etcd_certmanagers_group][0]
    - step_ca_service.state is defined
    - step_ca_service.state != 'started'
  failed_when: false
  changed_when: false

- name: Display step-ca logs on failure
  debug:
    var: step_ca_logs.stdout_lines
  when:
    - inventory_hostname == groups[etcd_certmanagers_group][0]
    - step_ca_service.state is defined
    - step_ca_service.state != 'started'

- name: Wait for step-ca to be ready (localhost check)
  uri:
    url: "https://localhost:{{ step_ca_port }}/health"
    validate_certs: no
    status_code: 200
  register: result
  until: result.status == 200
  retries: 10
  delay: 3
  when: inventory_hostname == groups[etcd_certmanagers_group][0]

- name: Get root CA certificate (force fresh read - from primary only)
  slurp:
    src: "{{ step_ca_certs }}/root_ca.crt"
  register: step_root_ca
  when: inventory_hostname == groups[etcd_certmanagers_group][0]
  
- name: Clear any cached root CA facts (ensure fresh distribution)
  set_fact:
    step_ca_root_cert: ""
  delegate_to: "{{ item }}"
  delegate_facts: true
  loop: "{{ groups[etcd_cluster_group] + groups[etcd_clients_group] }}"
  when: etcd_force_certs | default(false) | bool

- name: Store root CA as fact (fresh from regenerated CA - from primary)
  set_fact:
    step_ca_root_cert: "{{ step_root_ca.content | b64decode }}"
  delegate_to: "{{ item }}"
  delegate_facts: true
  loop: "{{ groups[etcd_cluster_group] + groups[etcd_clients_group] }}"
  when: inventory_hostname == groups[etcd_certmanagers_group][0]


- name: Display CA replication skip notice for new clusters
  debug:
    msg:
      - "‚è≠Ô∏è  SKIPPING CA REPLICATION (New Cluster Mode)"
      - ""
      - "Reason: etcd_new_cluster={{ etcd_new_cluster | default(false) }}"
      - ""
      - "This is EXPECTED for initial cluster deployment."
      - "No CA backup exists yet because this is the first deployment."
      - ""
      - "What happens:"
      - "1. ‚úÖ Primary cert-manager ({{ groups[etcd_certmanagers_group][0] }}) has step-ca RUNNING"
      - "2. ‚è≠Ô∏è  Backup cert-managers ({{ groups[etcd_certmanagers_group][1:] | join(', ') }}) will NOT get CA replicated yet"
      - "3. ‚úÖ CA backup will be created by automated cron (runs every 5 minutes)"
      - ""
      - "To replicate CA to backup cert-managers after deployment:"
      - "  Wait 5-10 minutes for first CA backup, then run:"
      - "  ansible-playbook -i inventory.ini playbooks/replicate-ca.yaml -b"
      - ""
      - "Or deploy again without etcd_new_cluster flag (auto-detects existing cluster):"
      - "  ansible-playbook -i inventory.ini etcd.yaml -e etcd_action=deploy -b"
  when:
    - groups[etcd_certmanagers_group] | length > 1
    - etcd_new_cluster | default(false) | bool
  run_once: true

- name: Replicate CA keys to backup cert-managers using encrypted backup/restore
  block:
    - name: Create encrypted CA backup on primary
      include_role:
        name: etcd3/backups/ca
      vars:
        ca_backup_action: replication
      when: inventory_hostname == groups[etcd_certmanagers_group][0]

    - name: Wait for backup to appear in S3
      shell: >
        {{ bin_dir }}/aws s3api head-object
        --bucket {{ step_ca_backup_s3_bucket }}
        --key {{ step_ca_backup_s3_prefix | regex_replace('/$', '') }}/{{ etcd_cluster_name }}/latest-ca-backup.tar.gz.{{ 'kms' if step_ca_backup_encryption_method == 'aws-kms' else ('enc' if step_ca_backup_encryption_method == 'symmetric' else '') }}
      environment:
        PATH: "{{ bin_dir }}:{{ ansible_env.PATH }}"
        AWS_ACCESS_KEY_ID: "{{ aws_access_key_id | default('') }}"
        AWS_SECRET_ACCESS_KEY: "{{ aws_secret_access_key | default('') }}"
        AWS_DEFAULT_REGION: "{{ aws_default_region | default('us-east-1') }}"
      register: s3_backup_check
      retries: 10
      delay: 3
      until: s3_backup_check.rc == 0
      changed_when: false
      failed_when: s3_backup_check.rc != 0
      when: inventory_hostname == groups[etcd_certmanagers_group][0]

    - name: Fail with helpful message if S3 backup not found
      fail:
        msg:
          - "‚ùå CA BACKUP NOT FOUND IN S3"
          - ""
          - "Expected S3 key: {{ step_ca_backup_s3_prefix | regex_replace('/$', '') }}/{{ etcd_cluster_name }}/latest-ca-backup.tar.gz.{{ 'kms' if step_ca_backup_encryption_method == 'aws-kms' else ('enc' if step_ca_backup_encryption_method == 'symmetric' else '') }}"
          - "S3 bucket: {{ step_ca_backup_s3_bucket }}"
          - ""
          - "Error from AWS:"
          - "{{ s3_backup_check.stderr | default('S3 check was skipped or failed') }}"
          - ""
          - "This is likely because:"
          - "1. This is a NEW cluster (first deployment) - backup doesn't exist yet"
          - "2. CA backup failed to upload to S3"
          - "3. S3 path is incorrect (check for double slashes or wrong prefix)"
          - ""
          - "Solutions:"
          - ""
          - "For NEW cluster deployment:"
          - "  This is EXPECTED on first deployment. Deploy without HA cert-managers first:"
          - "  1. Remove backup cert-managers from inventory temporarily"
          - "  2. Deploy with single cert-manager:"
          - "     ansible-playbook -i inventory.ini etcd.yaml -e etcd_action=deploy -e etcd_new_cluster=true -b"
          - "  3. Wait for CA backup to be created (automated cron runs every 5 minutes)"
          - "  4. Add backup cert-managers back to inventory"
          - "  5. Run replication:"
          - "     ansible-playbook -i inventory.ini playbooks/replicate-ca.yaml -b"
          - ""
          - "For existing cluster (backup should exist):"
          - "  1. Check S3 bucket and path:"
          - "     aws s3 ls s3://{{ step_ca_backup_s3_bucket }}/{{ step_ca_backup_s3_prefix | regex_replace('/$', '') }}/{{ etcd_cluster_name }}/ --recursive"
          - "  2. Verify CA backup ran on primary:"
          - "     ssh {{ groups[etcd_certmanagers_group][0] }} 'tail -50 {{ ca_backup_log_file }}'"
          - "  3. Manually trigger backup:"
          - "     ansible {{ groups[etcd_certmanagers_group][0] }} -i inventory.ini -m shell -a 'python3 {{ backup_scripts_dir }}/ca-backup-check.py --config {{ ca_backup_config_file }} --force' -b"
          - ""
          - "Skip HA cert-managers for now:"
          - "  Deploy with only primary cert-manager (etcd_new_cluster=true skips replication)"
      when:
        - inventory_hostname == groups[etcd_certmanagers_group][0]
        - s3_backup_check is defined
        - s3_backup_check.rc is defined
        - s3_backup_check.rc != 0

    - name: Restore CA on backup cert-managers from encrypted S3 backup
      include_role:
        name: etcd3/restore
      vars:
        restore_action: ca-from-backup
        restore_ca: true
        restore_ca_from: s3
        restore_ca_s3_file: latest
        restore_confirm: false  # No prompt during deployment
      when: inventory_hostname in groups[etcd_certmanagers_group][1:]
      register: ca_restore_result
      # Role will fail automatically if restore fails
      # This prevents deploying with mismatched CA keys across cert-managers

    - name: Check if step-ca service exists on backup cert-managers
      stat:
        path: /etc/systemd/system/step-ca.service
      register: step_ca_service_file
      when: inventory_hostname in groups[etcd_certmanagers_group][1:]
      tags:
        - ca-restore

    - name: Ensure step-ca is stopped on backup cert-managers
      systemd:
        name: step-ca
        enabled: no
        state: stopped
      when: 
        - inventory_hostname in groups[etcd_certmanagers_group][1:]
        - step_ca_service_file.stat.exists | default(false)
      tags:
        - ca-restore

    - name: Verify CA fingerprints match across all cert-managers
      shell: "{{ bin_dir }}/step certificate fingerprint {{ step_ca_certs }}/root_ca.crt"
      environment:
        PATH: "{{ bin_dir }}:{{ ansible_env.PATH }}"
      register: ca_fingerprint
      changed_when: false
      failed_when: false
      when: inventory_hostname in groups[etcd_certmanagers_group]

    - name: Collect all CA fingerprints
      set_fact:
        all_ca_fingerprints: "{{ groups[etcd_certmanagers_group] | map('extract', hostvars, 'ca_fingerprint') | map(attribute='stdout', default='') | select('string') | select() | list }}"
      run_once: true

    - name: Assert all CA fingerprints are identical
      assert:
        that:
          - all_ca_fingerprints | length > 0
          - all_ca_fingerprints | unique | length == 1
        fail_msg:
          - "‚ùå CA FINGERPRINT MISMATCH across cert-managers!"
          - ""
          - "This means backup cert-managers have different CA keys than primary."
          - ""
          - "Fingerprints:"
          - "{% for host in groups[etcd_certmanagers_group] %}  {{ host }}: {{ hostvars[host].get('ca_fingerprint', {}).get('stdout', 'NOT FOUND') }}{% endfor %}"
          - ""
          - "Root causes:"
          - "1. Backup cert-manager has OLD CA from previous deployment"
          - "2. S3 'latest' backup points to WRONG backup (old CA)"
          - "3. Backup/restore race condition (backup not ready yet)"
          - ""
          - "Solutions:"
          - ""
          - "Option 1: Force CA replication (clean and retry - backup nodes only)"
          - "  1. Clean old CA on backup nodes:"
          - "     ansible etcd-cert-managers[1:] -i inventory.ini -m file -a 'path=/etc/step-ca state=absent' -b"
          - "  2. Retry deployment:"
          - "     ansible-playbook -i inventory.ini etcd.yaml -e etcd_action=deploy -e etcd_force_ca_replication=true -b"
          - ""
          - "Option 2: Manual CA replication (use timestamped backup)"
          - "  1. Find the backup just created:"
          - "     aws s3 ls s3://{{ step_ca_backup_s3_bucket }}/{{ step_ca_backup_s3_prefix }}/ --recursive | tail -5"
          - "  2. Manually replicate using specific backup:"
          - "     ansible-playbook -i inventory.ini playbooks/replicate-ca.yaml"
          - ""
          - "Option 3: Investigate S3 'latest' pointer"
          - "  1. Check what 'latest' points to:"
          - "     aws s3api head-object --bucket {{ step_ca_backup_s3_bucket }} --key {{ step_ca_backup_s3_prefix }}/latest-ca-backup.tar.gz.{{ 'kms' if step_ca_backup_encryption_method == 'aws-kms' else 'enc' }}"
          - "  2. List all backups chronologically:"
          - "     aws s3 ls s3://{{ step_ca_backup_s3_bucket }}/{{ step_ca_backup_s3_prefix }}/ --recursive | grep -v '.sha256' | sort -k1,2"
          - "  3. The backup just created should be the MOST RECENT"
          - ""
          - "Temporary workaround:"
          - "  Add -e etcd_force_ca_replication=true to deployment"
        success_msg: "‚úÖ All cert-managers have identical CA (fingerprint: {{ all_ca_fingerprints[0] }})"
      run_once: true
      when: 
        - all_ca_fingerprints | length > 0
        - not (etcd_force_ca_replication | default(true) | bool)

    - name: Display CA fingerprint warning (force mode)
      debug:
        msg:
          - "‚ö†Ô∏è  WARNING: CA fingerprint verification SKIPPED (etcd_force_ca_replication=true)"
          - ""
          - "Fingerprints across cert-managers:"
          - "{% for host in groups[etcd_certmanagers_group] %}  {{ host }}: {{ hostvars[host].get('ca_fingerprint', {}).get('stdout', 'NOT FOUND') }}{% endfor %}"
          - ""
          - "{% if all_ca_fingerprints | unique | length != 1 %}‚ùå FINGERPRINTS DO NOT MATCH - manual investigation required{% else %}‚úÖ Fingerprints match{% endif %}"
          - ""
          - "Next steps if fingerprints don't match:"
          - "1. Clean backup cert-managers:"
          - "   ansible etcd-cert-managers[1:] -i inventory.ini -m file -a 'path=/etc/step-ca state=absent' -b"
          - "2. Manually replicate:"
          - "   ansible-playbook -i inventory.ini playbooks/replicate-ca.yaml"
      run_once: true
      when:
        - all_ca_fingerprints | length > 0
        - etcd_force_ca_replication | default(true) | bool

    - name: Display HA configuration status (successful replication)
      debug:
        msg:
          - "‚úÖ HA Configuration Complete"
          - ""
          - "CA backed up to: s3://{{ step_ca_backup_s3_bucket }}/{{ step_ca_backup_s3_prefix }}/"
          - "Encryption: {{ step_ca_backup_encryption_method }}"
          - ""
          - "Backup cert-managers: {{ groups[etcd_certmanagers_group][1:] | join(', ') }}"
          - "CA fingerprint: {{ ca_fingerprint.stdout }}"
          - ""
          - "Benefits:"
          - "- CA keys transmitted encrypted via {{ step_ca_backup_encryption_method }}"
          - "- Backup/restore tested during deployment"
          - "- Ready for disaster recovery"
      when: 
        - inventory_hostname == groups[etcd_certmanagers_group][0]
        - all_ca_fingerprints | length > 1
        - all_ca_fingerprints | unique | length == 1

    - name: Display HA configuration status (initial deployment)
      debug:
        msg:
          - "‚ö†Ô∏è  HA Configuration - Initial Deployment"
          - ""
          - "Primary cert-manager: {{ groups[etcd_certmanagers_group][0] }} (step-ca RUNNING)"
          - "Backup cert-managers: {{ groups[etcd_certmanagers_group][1:] | join(', ') }}"
          - ""
          - "CA fingerprint: {{ ca_fingerprint.stdout }}"
          - ""
          - "{% if 'etcd_all' in groups %}Multi-cluster: This CA serves all clusters{% endif %}"
          - ""
          - "NOTE: This is the first deployment, so backup cert-managers do not have CA keys yet."
          - ""
          - "CA backup is being created and will be available for replication soon."
          - ""
          - "To manually replicate CA keys to backup nodes later:"
          - "  ansible-playbook -i inventory.ini playbooks/replicate-ca.yaml"
          - ""
          - "Automated CA backup will run every 5 minutes (checks for changes)."
      when: 
        - inventory_hostname == groups[etcd_certmanagers_group][0]
        - all_ca_fingerprints | length <= 1

  when:
    - groups[etcd_certmanagers_group] | length > 1
    - not (etcd_force_certs | default(false) | bool)  # Skip during certificate regeneration
    - not (etcd_new_cluster | default(false) | bool)  # Skip CA replication for new clusters (no backup exists yet)
