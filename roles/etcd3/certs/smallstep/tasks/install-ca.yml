---
- name: Create step-ca directories (owned by root, step-ca runs as root)
  file:
    path: "{{ item }}"
    state: directory
    owner: root
    group: root
    mode: 0700
  loop:
    - "{{ step_path }}"
    - "{{ step_path }}/config"
    - "{{ step_ca_db }}"
    - "{{ step_ca_certs }}"
    - "{{ step_ca_secrets }}"

- name: Check if step-ca is installed
  stat:
    path: "{{ bin_dir }}/step-ca"
  register: step_ca_installed

- name: Fail if step-ca binary not installed
  fail:
    msg: |
      ❌ step-ca binary not found
      Expected location: {{ bin_dir }}/step-ca
      
      The download role should have installed this already.
      
      Manual installation:
         curl -L -o /tmp/step-ca.tar.gz https://github.com/smallstep/certificates/releases/download/v{{ step_ca_version }}/step-ca_linux_{{ step_ca_version }}_amd64.tar.gz
         tar -xzf /tmp/step-ca.tar.gz -C /tmp
         cp /tmp/step-ca {{ bin_dir }}/step-ca
         chmod 755 {{ bin_dir }}/step-ca
  when: not step_ca_installed.stat.exists

- name: Check if step CLI is installed
  stat:
    path: "{{ bin_dir }}/step"
  register: step_cli_installed

- name: Fail if step CLI binary not installed
  fail:
    msg: |
      ❌ step CLI binary not found
      Expected location: {{ bin_dir }}/step
      
      The download role should have installed this already.
      
      Manual installation:
         curl -L -o /tmp/step.tar.gz https://github.com/smallstep/cli/releases/download/v{{ step_version }}/step_linux_{{ step_version }}_amd64.tar.gz
         tar -xzf /tmp/step.tar.gz -C /tmp
         cp /tmp/step_{{ step_version }}/bin/step {{ bin_dir }}/step
         chmod 755 {{ bin_dir }}/step
  when: not step_cli_installed.stat.exists

- name: Check if CA already initialized
  stat:
    path: "{{ step_ca_config }}"
  register: step_ca_config_stat

- name: Initialize step-ca
  shell: |
    {{ bin_dir }}/step ca init \
      --name="{{ step_ca_name }}" \
      --dns="{{ step_ca_dns }}" \
      --address=":{{ step_ca_port }}" \
      --provisioner="{{ step_ca_provisioner }}" \
      --password-file=<(echo "{{ step_ca_password }}") \
      --provisioner-password-file=<(echo "{{ step_provisioner_password }}") \
      --dns="127.0.0.1" \
      --dns="localhost"
  args:
    executable: /bin/bash
  environment:
    STEPPATH: "{{ step_path }}"
  when: not step_ca_config_stat.stat.exists

- name: Copy step-ca configuration script
  template:
    src: configure_step_ca_durations.py.j2
    dest: /tmp/configure_step_ca_durations.py
    mode: 0755
  when: not step_ca_config_stat.stat.exists

- name: Configure step-ca certificate durations
  command: /usr/bin/python3 /tmp/configure_step_ca_durations.py
  register: configure_durations_result
  when: not step_ca_config_stat.stat.exists

- name: Display configuration result
  debug:
    var: configure_durations_result.stdout
  when: 
    - not step_ca_config_stat.stat.exists
    - configure_durations_result is defined

- name: Cleanup configuration script
  file:
    path: /tmp/configure_step_ca_durations.py
    state: absent
  when: not step_ca_config_stat.stat.exists

- name: Create step-ca systemd service
  template:
    src: step-ca.service.j2
    dest: /etc/systemd/system/step-ca.service
    mode: 0644
  notify: restart step-ca

- name: Create step-ca password file
  copy:
    content: "{{ step_ca_password }}"
    dest: "{{ step_ca_secrets }}/password"
    owner: root
    group: root
    mode: 0400

- name: Fix ownership and permissions of ALL CA files (step-ca runs as root)
  file:
    path: "{{ item.path }}"
    owner: root
    group: root
    mode: "{{ item.mode }}"
    state: "{{ item.state }}"
    recurse: "{{ item.recurse | default(false) }}"
  loop:
    - { path: "{{ step_path }}", mode: "0755", state: "directory", recurse: false }
    - { path: "{{ step_ca_secrets }}", mode: "0700", state: "directory", recurse: false }
    - { path: "{{ step_ca_certs }}", mode: "0755", state: "directory", recurse: false }
    - { path: "{{ step_ca_config }}", mode: "0640", state: "file" }
    - { path: "{{ step_ca_db }}", mode: "0700", state: "directory", recurse: false }
  loop_control:
    label: "{{ item.path }}"

- name: Fix CA secrets files permissions (private keys - root only)
  file:
    path: "{{ item }}"
    owner: root
    group: root
    mode: 0400
  loop:
    - "{{ step_ca_secrets }}/root_ca_key"
    - "{{ step_ca_secrets }}/intermediate_ca_key"
    - "{{ step_ca_secrets }}/password"
  failed_when: false

- name: Fix CA certificate permissions (root only, NOT world-readable)
  file:
    path: "{{ item }}"
    owner: root
    group: root
    mode: 0400
  loop:
    - "{{ step_ca_certs }}/root_ca.crt"
    - "{{ step_ca_certs }}/intermediate_ca.crt"
  failed_when: false

- name: Enable and start step-ca service
  systemd:
    name: step-ca
    enabled: yes
    state: started
    daemon_reload: yes
  register: step_ca_service

- name: Display step-ca runtime configuration
  debug:
    msg: |
      step-ca runtime limit: {{ 'INFINITE (always running)' if step_ca_runtime_minutes | int == 0 else (step_ca_runtime_minutes | string) + ' minutes' }}
      {% if step_ca_runtime_minutes | int > 0 %}
      
      Security note: step-ca will automatically stop after {{ step_ca_runtime_minutes }} minutes.
      This minimizes attack surface by only running the CA when needed.
      
      To restart step-ca manually:
        systemctl start step-ca
      
      step-ca will also restart automatically when certificates are renewed.
      {% endif %}

- name: Check step-ca service status
  command: systemctl status step-ca
  register: step_ca_status
  failed_when: false
  changed_when: false

- name: Show step-ca service status if it failed to start
  debug:
    var: step_ca_status.stdout_lines
  when: step_ca_service.state != 'started'

- name: Show step-ca logs if service failed
  command: journalctl -u step-ca -n 50 --no-pager
  register: step_ca_logs
  when: step_ca_service.state != 'started'
  failed_when: false
  changed_when: false

- name: Display step-ca logs on failure
  debug:
    var: step_ca_logs.stdout_lines
  when: step_ca_service.state != 'started'

- name: Wait for step-ca to be ready (localhost check)
  uri:
    url: "https://localhost:{{ step_ca_port }}/health"
    validate_certs: no
    status_code: 200
  register: result
  until: result.status == 200
  retries: 10
  delay: 3

- name: Get root CA certificate
  slurp:
    src: "{{ step_ca_certs }}/root_ca.crt"
  register: step_root_ca
  
- name: Store root CA as fact
  set_fact:
    step_ca_root_cert: "{{ step_root_ca.content | b64decode }}"
  delegate_to: "{{ item }}"
  delegate_facts: true
  loop: "{{ groups[etcd_cluster_group] + groups[etcd_clients_group] }}"

- name: Replicate CA keys to backup cert-managers using encrypted backup/restore
  block:
    - name: Create encrypted CA backup on primary
      include_role:
        name: etcd3/backups/ca
      vars:
        ca_backup_action: replication
      when: inventory_hostname == groups[etcd_certmanagers_group][0]

    - name: Wait for backup to appear in S3
      shell: >
        {{ bin_dir }}/aws s3api head-object
        --bucket {{ step_ca_backup_s3_bucket }}
        --key {{ step_ca_backup_s3_prefix }}/latest-ca-backup.tar.gz.{{ 'kms' if step_ca_backup_encryption_method == 'aws-kms' else ('enc' if step_ca_backup_encryption_method == 'symmetric' else '') }}
      environment:
        PATH: "{{ bin_dir }}:{{ ansible_env.PATH }}"
        AWS_ACCESS_KEY_ID: "{{ aws_access_key_id | default('') }}"
        AWS_SECRET_ACCESS_KEY: "{{ aws_secret_access_key | default('') }}"
        AWS_DEFAULT_REGION: "{{ aws_default_region | default('us-east-1') }}"
      register: s3_backup_check
      retries: 10
      delay: 3
      until: s3_backup_check.rc == 0
      changed_when: false
      when: inventory_hostname == groups[etcd_certmanagers_group][0]

    - name: Restore CA on backup cert-managers from encrypted S3 backup
      include_role:
        name: etcd3/restore
      vars:
        restore_action: ca-from-backup
        restore_ca: true
        restore_ca_from: s3
        restore_ca_s3_file: latest
        restore_confirm: false  # No prompt during deployment
      when: inventory_hostname in groups[etcd_certmanagers_group][1:]
      ignore_errors: true  # Allow failure during initial deployment when no backup exists yet
      register: ca_restore_result

    - name: Check if step-ca service exists on backup cert-managers
      stat:
        path: /etc/systemd/system/step-ca.service
      register: step_ca_service_file
      when: inventory_hostname in groups[etcd_certmanagers_group][1:]
      tags:
        - ca-restore

    - name: Ensure step-ca is stopped on backup cert-managers
      systemd:
        name: step-ca
        enabled: no
        state: stopped
      when: 
        - inventory_hostname in groups[etcd_certmanagers_group][1:]
        - step_ca_service_file.stat.exists | default(false)
      tags:
        - ca-restore

    - name: Verify CA fingerprints match across all cert-managers
      shell: "{{ bin_dir }}/step certificate fingerprint {{ step_ca_certs }}/root_ca.crt"
      environment:
        PATH: "{{ bin_dir }}:{{ ansible_env.PATH }}"
      register: ca_fingerprint
      changed_when: false
      failed_when: false
      when: inventory_hostname in groups[etcd_certmanagers_group]

    - name: Collect all CA fingerprints
      set_fact:
        all_ca_fingerprints: "{{ groups[etcd_certmanagers_group] | map('extract', hostvars, 'ca_fingerprint') | map(attribute='stdout', default='') | select('string') | select() | list }}"
      run_once: true

    - name: Assert all CA fingerprints are identical
      assert:
        that:
          - all_ca_fingerprints | length > 0
          - all_ca_fingerprints | unique | length == 1
        fail_msg: |
          ❌ CA FINGERPRINT MISMATCH across cert-managers!
          
          This means backup cert-managers have different CA keys than primary.
          
          Fingerprints:
          {% for host in groups[etcd_certmanagers_group] %}
          {{ host }}: {{ hostvars[host].get('ca_fingerprint', {}).get('stdout', 'NOT FOUND') }}
          {% endfor %}
          
          This should never happen during deployment.
          Contact support or check logs.
        success_msg: "✅ All cert-managers have identical CA (fingerprint: {{ all_ca_fingerprints[0] }})"
      run_once: true
      when: all_ca_fingerprints | length > 0

    - name: Display HA configuration status (successful replication)
      debug:
        msg: |
          ✅ HA Configuration Complete
          
          CA backed up to: s3://{{ step_ca_backup_s3_bucket }}/{{ step_ca_backup_s3_prefix }}/
          Encryption: {{ step_ca_backup_encryption_method }}
          
          Backup cert-managers: {{ groups[etcd_certmanagers_group][1:] | join(', ') }}
          CA fingerprint: {{ ca_fingerprint.stdout }}
          
          Benefits:
          - CA keys transmitted encrypted via {{ step_ca_backup_encryption_method }}
          - Backup/restore tested during deployment
          - Ready for disaster recovery
      when: 
        - inventory_hostname == groups[etcd_certmanagers_group][0]
        - all_ca_fingerprints | length > 1
        - all_ca_fingerprints | unique | length == 1

    - name: Display HA configuration status (initial deployment)
      debug:
        msg: |
          ⚠️  HA Configuration - Initial Deployment
          
          Primary cert-manager: {{ groups[etcd_certmanagers_group][0] }} (step-ca RUNNING)
          Backup cert-managers: {{ groups[etcd_certmanagers_group][1:] | join(', ') }}
          
          CA fingerprint: {{ ca_fingerprint.stdout }}
          
          NOTE: This is the first deployment, so backup cert-managers don't have CA keys yet.
          
          CA backup is being created and will be available for replication soon.
          
          To manually replicate CA keys to backup nodes later:
            ansible-playbook -i inventory.ini playbooks/replicate-ca.yaml
          
          Automated CA backup will run every 5 minutes (checks for changes).
      when: 
        - inventory_hostname == groups[etcd_certmanagers_group][0]
        - all_ca_fingerprints | length <= 1

  when:
    - groups[etcd_certmanagers_group] | length > 1
